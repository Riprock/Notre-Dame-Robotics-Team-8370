#pragma config(Sensor, dgtl1,  backSonar,      sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  LED,            sensorDigitalOut)
#pragma config(Sensor, dgtl9,  leftRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, forwardBack,    sensorQuadEncoder)
#pragma config(Motor,  port2,           frontm,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           backm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightm,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float forwardSpeed;
float sidewaysSpeed;
int distance;
float speedDivisor;

float turnSpeed;

void stopm(){
	motor[rightm]=0;
	motor[leftm]=0;
	motor[frontm]=0;
	motor[backm]=0;
}

void forward(float fdistance){
	SensorValue[LED] = true;
	SensorValue[forwardBack] = 0;
	while (SensorValue[forwardBack] < 360 * (fdistance/17)){
			motor[leftm] = 50;
			motor[rightm] = 50;
	}
	stopm();
	SensorValue[LED] = false;
}

void backward(float fdistance){
	SensorValue[forwardBack] = 0;
	while (SensorValue[leftRight] < 360 * (fdistance/17)){
			motor[leftm] = -50;
			motor[rightm] = -50;
	}
}

void jonnie(){
	motor[rightm]=forwardSpeed - turnSpeed;
	motor[leftm]=forwardSpeed + turnSpeed;
	motor[frontm]=sidewaysSpeed + turnSpeed;
	motor[backm]=sidewaysSpeed - turnSpeed;
}

task main(){
		forward(48);
		while(true) {
			SensorValue[LED] = false;
			if (vexRT[Btn6U]==1){
				speedDivisor = 4;
			} else {
			speedDivisor = 2;
			}
			forwardSpeed = vexRT[Ch3] / speedDivisor;
			sidewaysSpeed = vexRT[Ch4] / speedDivisor;

			turnSpeed = vexRT[Ch1] / speedDivisor;

			//jonnie();
	}
	wait1Msec(3000);
}
