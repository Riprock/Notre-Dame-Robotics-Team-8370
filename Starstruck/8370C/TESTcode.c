#pragma config(Sensor, dgtl1,  backSonar,      sensorSONAR_inch)
#pragma config(Sensor, dgtl9,  leftRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, forwardBack,    sensorQuadEncoder)
#pragma config(Motor,  port2,           frontm,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           backm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightm,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           cright,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           cleft,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
// TODO UPDATE ABOVE PRAGMAS FOR CATAPULT MOTOR REVERSAL

float forwardSpeed;
float sidewaysSpeed;
float speedDivisor;
float turnSpeed;

/*
* Stops all robot movement.
*/
void stopm(){
	motor[rightm]=0;
	motor[leftm]=0;
	motor[frontm]=0;
	motor[backm]=0;
}
/*
* Moves the robot forward idistance number of inches.
* 24 inches = one tile
*/
void forward(float idistance){
	SensorValue[forwardBack] = 0;
	while (SensorValue[forwardBack] < 360 * (idistance/17)){
			motor[leftm] = 50;
			motor[rightm] = 50;
	}
	stopm();
}
/*
* Moves the robot backward idistance number of inches.
*/
void backward(float idistance){
	SensorValue[forwardBack] = 0;
	while (SensorValue[leftRight] < 360 * (idistance/17)){
			motor[leftm] = -50;
			motor[rightm] = -50;
	}
	stopm();
}

/*
* Moves the robot based upon controller input.
*/
void controllerMovement(){
	// Determine movement speeds based on controller input
	speedDivisor = 2+(2*vexRT[Btn6U]); // Upper Right trigger cuts speed in half
	forwardSpeed = vexRT[Ch3] / speedDivisor; // Left stick determines forward...
	sidewaysSpeed = vexRT[Ch4] / speedDivisor; // ...and sideways speeds
	turnSpeed = vexRT[Ch1] / speedDivisor; // Right stick determines turning speed

	// Apply speeds for each motor
	motor[rightm] = forwardSpeed - turnSpeed;
	motor[leftm] = forwardSpeed + turnSpeed;
	motor[frontm] = sidewaysSpeed + turnSpeed;
	motor[backm] = sidewaysSpeed - turnSpeed;
}

task main(){
		while(true) {

			controllerMovement();
			wait1Msec(200); // Added to save battery for open house demonstration

	}
}
