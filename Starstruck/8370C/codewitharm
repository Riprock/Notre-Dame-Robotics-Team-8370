#pragma config(Sensor, dgtl1,  backSonar,      sensorSONAR_inch)
#pragma config(Sensor, dgtl9,  leftRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, forwardBack,    sensorQuadEncoder)
#pragma config(Motor,  port2,           frontm,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           backm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightm,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           cLeft1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           cRight1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           cLeft2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           cRight2,       tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

// Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// DRIVER CONTROL SPEEDS
float forwardSpeed;
float sidewaysSpeed;
float speedDivisor;
float turnSpeed;

/*
* Stops all robot movement.
*/
void stopm(){
	motor[rightm]=0;
	motor[leftm]=0;
	motor[frontm]=0;
	motor[backm]=0;
}
/*
* Moves the robot forward idistance number of inches.
*/
void forward(float idistance, float speed){
	SensorValue[forwardBack] = 0;
	while (SensorValue[forwardBack] < 360 * (idistance/17)){
			motor[leftm] = -speed;
			motor[rightm] = -speed;
	}
	stopm();
}

void tforward(float timemsec, float speed){
	motor[leftm] = -speed;
	motor[rightm] = -speed;
	wait1Msec(timemsec);
	stopm();
}

/*
* Moves the robot backward idistance number of inches.
*/
void backward(float idistance, float speed){
	SensorValue[forwardBack] = 0;
	while (SensorValue[forwardBack] > -360 * (idistance/17)){
			motor[leftm] = speed;
			motor[rightm] = speed;
	}
	stopm();
}

/*
* Moves the robot based upon controller input.
*/
void controllerMovement(){
	// Determine movement speeds based on controller input
	speedDivisor = 2+(2*vexRT[Btn6U]); // Upper Right trigger cuts speed in half
	forwardSpeed = vexRT[Ch3] / speedDivisor; // Left stick determines forward...
	sidewaysSpeed = vexRT[Ch4] / speedDivisor; // ...and sideways speeds
	turnSpeed = vexRT[Ch1] / speedDivisor; // Right stick determines turning speed

	// Apply speeds for each movement motor
	motor[rightm] = -(forwardSpeed - turnSpeed);
	motor[leftm] = -(forwardSpeed + turnSpeed);
	motor[frontm] = sidewaysSpeed + turnSpeed;
	motor[backm] = sidewaysSpeed - turnSpeed;

	// Move arm motors at full speed according to shoudler buttons.
	motor[cLeft1] = vexRT[Btn6D]*60;
	motor[cRight1] = vexRT[Btn6D]*60;
	motor[cLeft2] = vexRT[Btn6D]*60;
	motor[cRight2] = vexRT[Btn6D]*60;
	motor[cLeft1] = -vexRT[Btn5D]*60;
	motor[cRight1] = -vexRT[Btn5D]*60;
	motor[cLeft2] = -vexRT[Btn5D]*60;
	motor[cRight2] = -vexRT[Btn5D]*60;
}

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

task autonomous()
{
  forward(24, 50);
  backward(5, 127);
  forward(2, 50);
  backward(5, 127);
  tforward(4000, 127);
  backward(70, 127);
}

task usercontrol()
{
  // User control code here, inside the loop

  while (true)
  {
    controllerMovement();
  }
}
